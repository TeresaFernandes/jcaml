//////////////////
//	Problema 1	//
//////////////////
let pow = function(x:int) -> x*x;

let problema1 = function (x:int, y:int,c:int) -> 
	pow(x) - y + c;
	

//////////////////
//	Problema 2	//
//////////////////
let problema2_intervalo1 = function (x:int) -> 
	if x>=0 then 
		if x<=25 then true
		else false
	else false;
	
let problema2_intervalo2 = function (x:int) ->
	if x>=26 then 
		if x<=50 then true
		else false
	else false;
	
let problema2_intervalo3 = function (x:int) ->
	if x>=51 then 
		if x<=75 then true
		else false
	else false;
	
let problema2_intervalo4 = function (x:int) ->
	if x>=76 then 
		if x<=100 then true
		else false
	else false;
	


//////////////////
//	Problema 4	//
//////////////////
type rational_t = { numerador:int, denominador:int };

let problema4_a = rational_t;

let problema4_b = function(v1:custom,v2:custom) ->
	if v1.numerador==v2.numerador then 
		v1.denominador==v2.denominador
	else false;
	
let var1 = rational_t(2,2);
let var2 = rational_t(2,2);
problema4_b(var1,var2);

let problema4_c_mul = function (v1:custom,v2:custom) ->
	problema4_a(v1.numerador*v2.numerador,v1.denominador*v2.denominador);
	
let problema4_c_div = function (v1:custom,v2:custom) ->
	problema4_a(v1.numerador*v2.denominador,v1.denominador*v2.numerador);

let problema4_c_inv = function (v1:custom) ->
	problema4_a(v1.denominador,v1.numerador);

let problema4_c_neg = function (v1:custom) ->
	problema4_a(0-v1.numerador,v1.denominador);

let aux = function (x:int,y:int) -> x*y;
let problema4_c_soma = function (v1:custom, v2:custom) ->
	rational_t(aux(v1.numerador,v2.denominador) + aux(v1.denominador,v2.numerador),v1.denominador*v2.denominador);

let problema4_c_sub = function (v1:custom, v2:custom) ->
	rational_t(aux(v1.numerador,v2.denominador) - aux(v1.denominador,v2.numerador),v1.denominador*v2.denominador);


//////////////////
//	Problema 5	//
//////////////////
let resto_div = function (x:int,y:int) -> x % y;
let mdc = function(n:int,m:int) ->
	if resto_div(m,n)==0 then n
	else if resto_div(n,m)==0 then m
	else if m>n then mdc(n,m%n)
	else mdc(n%m,m);

